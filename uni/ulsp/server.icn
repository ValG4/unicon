# Date of creation:
#    12/8/22
#
# Date last updated:
#    12/9/22
#
# Author(s):
#    Mark Stowell,
#    Jonah Schnettler
#
# Description:
#
#
#
#
#


package ulsp

link ximage
link strings
import json
#import UniDoc

link strings
class Logger(
   log_destinations,    #zero or more log destinations
   current_log_level,   # the current log level
   debug_class_set,
   log_type_list,       #
   enable_stdout,       # log to stadout
   enable_stderr,       # log to stderr
   std_redirect,        # redirect output ("out", "err")
   enable_timestamp,    # add time stamp to log messages ("file", "all", "none")
   enable_loginfo,      # add log info to log messages ("file", "all", "none")
   clock
   )

   # private
   method _log(loglvl, msgs)
      local msg
      clock := &date || " " || &clock
      if loglvl <= current_log_level then {
         msg := ""; every msg ||:=!msgs
         self._log_to_file(msg, loglvl)
         self._log_std(msg, loglvl)
      }
   end

   # private, used with filters
   method _debug(loglvl, filter, msgs)
      local msg

      # every w := words(filter, ":") do {
      #    (/s:=w) | (s||:= ":" || w)
      #    if member(debug_class_set, s) then {
      #       match_filter := 1
      #       break
      #    }
      # }

      clock := &date || " " || &clock
      if loglvl <= current_log_level |
         (loglvl >= 8 & member(debug_class_set, filter))  then {
         msg := ""; every msg ||:=!msgs
         self._log_to_file(msg, loglvl, filter)
         self._log_std(msg, loglvl, filter)
      }
   end

   #private
   method _decorate_ts(is_file)
      local ts := ""
      if enable_timestamp == "all" | enable_timestamp == is_file == "file" then
         ts := ts := "[" || clock || "]"
      return ts
   end

   method _decorate_info(is_file, lvl, filter)
      local linfo := ""
      if enable_loginfo == "all" | enable_loginfo == is_file == "file" then
         linfo := "[" || log_type_list[lvl] || (if /filter then "" else  (":" ||filter )) || "]"
      return linfo
   end

   method decoration(is_file, lvl, filter)
      return _decorate_ts(is_file) || _decorate_info(is_file, lvl, filter) || " "
   end

   # private
   method _log_to_file(msg, lvl, filter)
      local decorate
      if *log_destinations > 0 then {
         decorate := decoration("file", lvl, filter)
         every write(!log_destinations, decorate, msg)
         every flush(!log_destinations)
      }
   end

   # private
   method _log_std(msg, lvl, filter)
      if (std_redirect ~== "err") & (lvl > 5 | std_redirect == "out") then {
         if \enable_stdout then
            write(&output, decoration("std", lvl, filter), msg)
      }
      else if lvl <= 5 | std_redirect == "err" then {
         if \enable_stderr then
            write(&errout, decoration("std", lvl, filter), msg)
      }
   end

   method add_debug_class(filter)
      insert(debug_class_set, filter)
   end

   method remove_debug_class(filter)
      delete(debug_class_set, filter)
   end

   # move all output to stderr
   method redirect_std_out_to_err()
      std_redirect := "err"
   end

   # always log this
   method log(msgs[])
      local msg
      msg := ""; every msg ||:=!msgs
      self._log_to_file(msg, 0)
      self._log_std(msg, 0)
   end

   method finalize()
      every close(!log_destinations)
   end

   # 1. The system is unusable.
   method emergency(msgs[])
      self._log(1, msgs)
   end

   # 2. Actions that must be taken care of immediately.
   method alert(msgs[])
      self._log(2, msgs)
   end

    # 3. Critical conditions.
   method crit(msgs[])
      self._log(3, msgs)
   end

   # 4. Non-critical error conditions.
   method error(msgs[])
      self._log(4, msgs)
   end

   # 5. Warning conditions that should be taken care of.
   method warn(msgs[])
      self._log(5, msgs)
   end

    # 6. Normal, but significant events.
   method notice(msgs[])
      self._log(6, msgs)
   end

   # 7. Informational messages that require no action.
   method info(msgs[])
      self._log(7, msgs)
   end

   # 8. debugging messages
   method debug(msgs[])
      self._log(8, msgs)
   end

   # associate a log with a filter
   method debug_class(filter, msgs[])
      self._debug(8, filter, msgs)
   end

   # associate a log with a debug level and a filter
   method debug_level_filter(lvl, filter, msgs[])
      self._debug(lvl+8, filter, msgs)
   end

   method debug1(msgs[])
      self._log(9, msgs)
   end

   method debug1_class(filter, msgs[])
      self._debug(9, filter, msgs)
   end

   method debug2(msgs[])
      self._log(10, msgs)
   end

   method debug2_class(filter, msgs[])
      self._debug(10, filter, msgs)
   end

   method debug3(msgs[])
      self._log(11, msgs)
   end

   method debug3_class(filter, msgs[])
      self._debug(11, filter, msgs)
   end

   method debug4(msgs[])
      self._log(12, msgs)
   end

   method debug4_class(filter, msgs[])
      self._debug(12, filter, msgs)
   end

   method debug5(msgs[])
      self._log(13, msgs)
   end

   method debug5_class(filter, msgs[])
      self._debug(13, filter, msgs)
   end

   method debug6(msgs[])
      self._log(14, msgs)
   end

   method debug6_class(filter, msgs[])
      self._debug(14, filter, msgs)
   end

   method debug7(msgs[])
      self._log(15, msgs)
   end

   method debug7_class(filter, msgs[])
      self._debug(15, filter, msgs)
   end

   method debug8(msgs[])
      self._log(16, msgs)
   end

   method debug8_class(filter, msgs[])
      self._debug(16, filter, msgs)
   end

   method debug9(msgs[])
      self._log(17, msgs)
   end

   method debug9_class(filter, msgs[])
      self._debug(17, filter, msgs)
   end

   initially(init_log_level, log_file_path)
      local f
      log_type_list := [
         #"none",       # 0. Disable logging completely.
         "emergency",   # 1. The system is unusable.
         "alert",       # 2. Actions that must be taken care of immediately.
         "critical",    # 3. Critical conditions.
         "error",       # 4. Non-critical error conditions.
         "warning",     # 5. Warning conditions that should be taken care of.
         "notice",      # 6. Normal, but significant events.
         "info",        # 7. Informational messages that require no action.
         "debug",       # 8. Debugging messages level 0.
         "debug1",      # 9. Debugging messages level 1.
         "debug2",      # 10
         "debug3",      # 11
         "debug4",      # 12
         "debug5",      # 13
         "debug6",      # 14
         "debug7",      # 15
         "debug8",      # 16
         "debug9",      # 17 Debugging messages level 9.
      ]

      enable_stdout := enable_stderr := 1
      std_redirect := "none"
      enable_timestamp := "file"
      enable_loginfo := "all"
      debug_class_set := set("")
      current_log_level := \init_log_level | 5
      log_destinations := []
      if \log_file_path then
         if f := open(log_file_path, "a") then
            put(log_destinations, f)

      Logger := self # make this a singleton class
end

class Server(
   port,                         # Port number acquired from args on start up of server
   mode,                         # Mode to run in (client | server)
   sock,                         # Socket connection for communication with client
   openFiles,                    # File container for open files
   completionHandler,            # Instance of CompletionHandler class for handling completion requests
   signatureHandler,
   hoverHandler,
   definitionHandler,
   lsp_database                  # table containing database of packages (i.e. main, graphics3d, etc.) and their files.
   )

   method run()
      local request_body, jsontable, request_method, request_params, request_id

      repeat {
         every request_body := get_request(sock) do {
            jsontable := jtou(request_body) | next

            request_method := jsontable["method"]
            request_params := jsontable["params"]
            request_id := jsontable["id"]

            write("-----------------------------------------")
            write(request_method)
            write("-----------------------------------------")

            case request_method of {
               "initialize" : initialize(request_id)
               "textDocument/didOpen" : didOpen(request_params)
               "textDocument/didClose" : didClose(request_params)
               "textDocument/didChange" : didChange(request_params)
               "textDocument/completion" : completion(request_id, request_params)
               "textDocument/signatureHelp" : signatureHelp(request_id, request_params)
               "textDocument/hover" : hoverHelp(request_id, request_params)
               "textDocument/definition" : definitionHelp(request_id, request_params)
               "$/cancelRequest" : cancelRequest(request_id)
               default: { write("Don't know what to do with: ", request_method) }
            }
         }
      }
   end

#################################################################################
#                               Get Request                                     #
#################################################################################

   method get_request(sock)
      local request_body, msg, len

      while /request_body | request_body == "" do {

         # Block and get message on socket
         select(sock)
         msg := ready(sock)

         # Handling socket reading anomoly: header alone or header + request_body
         while msg ~== "" do {
            msg ? {
               tab(find("Content-Length:") + 16)
               len := integer(tab(many(&digits)))
               tab(upto("\r\n\r\n") + 4)
               if pos(0) then {
                  request_body := ready(sock, len)
               }
               else {
                  request_body := move(len)
               }
               until *request_body = len do {
                  (*select(sock, 5000) ~= 0) | break
                  request_body ||:= ready(sock, len)
               }
               msg := tab(0)
            }
            suspend request_body
         }
      }
   end

#################################################################################
#                               Build Response                                  #
#################################################################################

   method build_response(id, results)
      local responseBody, responseHeader
      responseBody := "{\"jsonrpc\":\"2.0\",\"id\":"||id||",\"result\":"||results||"}"
      responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"
      return responseHeader || responseBody
   end


#################################################################################
#                     Response / notification Section                           #
#################################################################################

# This is the section for processing notifications and handling responses to requests.
# For future additions (capabilities), add an additional comment/code block similar to what is seen below.
# In addition to adding a procedure or block of code to process/handle the notification/request, be sure to add to the case statement in the loop.


########################################################
#                     initialize                       #
########################################################

# As you add more capabilities to the language server (i.e. hover, go to declaration, etc.) add these to the results string below.
# Follow the LSP specifications on how to add a particular capability to your initialize string.

   method initialize(request_id)
      local capabilitiesTable, result

      capabilitiesTable := ["capabilities": [
         "completionProvider": [
            "triggerCharacters": [".", ":"]
         ];
         "textDocumentSync": 1;
         "signatureHelpProvider": [
            "contextSupport": "__true__";
            "triggerCharacters": ["("]
         ];
         "hoverProvider": "__true__";
         "definitionProvider": "__true__"
      ]]

      result := build_response(request_id, tojson(capabilitiesTable))
      write(result)
      writes(sock, result)
   end

########################################################
#                textDocument/didOpen                  #
########################################################

   method didOpen(request_params)
      local fname, uri, f, initial_file_contents, workspace_object
      if \(uri := request_params["textDocument"]["uri"]) then {
         # uri: file://<PATH>
         uri ? {
            ="file://" | write(&errout, "unexpected uri:", uri)
            fname := tab(0)
         }

         if f := open(fname) then {
            initial_file_contents := reads(f, -1)
            close(f)
         }
      }

      openFiles[\uri] := Workspace(fname, lsp_database)
      workspace_object := openFiles[\uri]
      workspace_object.setFile()
      workspace_object.updateWorkspace()

   end

########################################################
#                textDocument/didClose                 #
########################################################

   method didClose(request_params)
      local uri
      uri := request_params["textDocument"]["uri"]
      delete(openFiles, \uri)
   end

########################################################
#                textDocument/didChange                #
########################################################

   method didChange(request_params)
      local fname, uri, f, file_contents, workspace_object, initial_file_contents
      if \(uri := request_params["textDocument"]["uri"]) then {
         # uri: file://<PATH>
         uri ? {
            ="file://" | write(&errout, "unexpected uri:", uri)
            fname := tab(0)
         }

         if f := open(fname) then {
            initial_file_contents := reads(f, -1)
            close(f)
         }
      }

      uri := request_params["textDocument"]["uri"]
      file_contents := request_params["contentChanges"][1]["text"]
      workspace_object := openFiles[\uri]
      workspace_object.updateUniDoc(fname, file_contents)
      workspace_object.updateWorkspace()
   end

########################################################
#                textDocument/completion               #
########################################################

   method completion(request_id, request_params)
      local uri, workspace_object, result, res
      uri := request_params["textDocument"]["uri"]
      workspace_object := openFiles[\uri]
      completionHandler.setVariables(workspace_object, request_params)
      result := completionHandler.run()
      res := build_response(request_id, result)
      writes(sock, res)
   end

########################################################
#              textDocument/signatureHelp              #
########################################################

   method signatureHelp(request_id, request_params)
      local uri, workspace_object, result, res
      uri := request_params["textDocument"]["uri"]
      workspace_object := openFiles[\uri]
      signatureHandler.setVariables(workspace_object, request_params)
      result := signatureHandler.run()
      res := build_response(request_id, result)
      writes(sock, res)
   end

########################################################
#              textDocument/hover                      #
########################################################

   method hoverHelp(request_id, request_params)
      local uri, workspace_object, result, res
      uri := request_params["textDocument"]["uri"]
      workspace_object := openFiles[\uri]
      hoverHandler.setVariables(workspace_object, request_params)
      result := hoverHandler.run()
      res := build_response(request_id, result)
      writes(sock, res)
   end

########################################################
#                textDocument/definition               #
########################################################

   method definitionHelp(request_id, request_params)
      local uri, workspace_object, result, res
      uri := request_params["textDocument"]["uri"]
      workspace_object := openFiles[\uri]
      definitionHandler.setVariables(workspace_object, request_params)
      result := definitionHandler.run()
      res := build_response(request_id, result)
      writes(sock, res)
   end

########################################################
#                  $/cancelRequest                     #
########################################################
# TODO:
#       One thread for communication
#       Spin up thread(s) for processing requests and tie request_id to thread
# Handling cancel requests:
#       kill thread associated with request_id

   method cancelRequest(request_id)
      write("We received a cancel request. We need to implement this still...")
   end

   method shutdown()

   end

   method loadDB()
      openFiles := table()
      lsp_database := LSPDB()
      lsp_database.build()
      completionHandler := CompletionHandler()
      signatureHandler := SignatureHandler()
      hoverHandler := HoverHandler()
      definitionHandler := DefinitionHandler()

   end


   initially
      local openopt := "n", mstring := "server"

      case mode of {
         "s" : { openopt ||:= "a" }
         "c" : { mstring := "client" }
         default: { write("Unknown mode: " || mode) }
      }

      \Logger | Logger(7) # default to informational

      Logger.info("Loading Database...")
      loadDB()
      Logger.info("Starting Unicon LSP in ", mstring, " mode at ", port)
      every 1 to 5 do {
         if sock := open(port, openopt) then
            break
         else {
            Logger.error("open(",port,") ERROR: ", \&errortext | "Unknown")
            delay(1000)
         }
      }

      if /sock then {
         Logger.crit("Failed to establish connection on: ", port)
         exit(1)
      }
end

