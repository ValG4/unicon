procedure report_error(msg)
   static region
   initial region:=mutex()

   critical region: {
      writes(msg)
      writes(" Error ")
      if writes((&errornumber | (0 ~= &errno))) then
         writes(": ")

      writes(&errortext)
      writes( " - ", &errorvalue)
      }
      return
end

class Server(addrport, mode, opt, rounds)
   method run()
      local sock
      every !rounds do {
          sock := &null
          sock := tcp_socket(addrport) # block and wait to accept a new connection
          if \sock then 
             tcp_session(sock)
          delay(50)
         }
   end

   method tcp_socket()
      local s
      write("\nOpen a tcp server socket(",mode,")")
      s := open ! opt |
         (report_error("\nserver open()") & fail)
      return s
   end

   method tcp_session(sock)
      repeat {
         if *select(sock) > 0 then {
            if (msg := ready(sock)) && msg ~=== "" then {
               writes(left("server:" || image(msg) || " => ", 20))
               writes(sock, msg)       # echo back to the client
               }
            else {  # We see activity on the socket but nothing to read, assume client has closed the socket
               close(sock)
               break # done, break out of the loop
            }
         }
      }
   end
   initially(p, m)
      addrport := p
      mode := m
       case mode of {
        "nae": rounds := 12&
           opt := [addrport, mode, "key=./data/unicon-server.key", "cert=./data/unicon-server.crt", 
                   "caFile=./data/unicon-ca.crt", "minProto=TLS1.2" ]
         default: rounds := 1 &  opt := [addrport, mode]
         }
end

class TCPClient(addrport, sock, mode, opt)
   method test(msg)
      local msg_reply
      writes(left("test> client:" || image(msg) || " => ", 28))

      writes(sock, msg) | (report_error("\n\nwrite(sock) Failed") & failed)
      if *select(sock) > 0 then
         if msg_reply := ready(sock) then {
            writes(" client: ")
            if msg == msg_reply then 
               write(left(image(msg_reply), 10), "OK")
            else
               write(left(image(msg_reply),10), "Failed")

            return
            }
         else  (report_error("\n\nclient ready(): ") & fail)
      return
   end

   method run()
      write("\nOpen a tcp client socket(",mode,")")
      sock := (open ! opt) |
         (report_error("\nclient open()") & fail)

      test("Unicon") &
      test("Is") &
      test("Awesome")

      close(sock)
   end

   initially(p, m)
      addrport := p
      mode := m
      case mode of {
         "Client Cert" : opt := [addrport, "ne", 5000,
                           "key=./data/unicon-client.key", "cert=./data/unicon-client.crt", "caFile=./data/unicon-ca.crt" ]
         "TLS" : opt := [addrport, "ne", 5000]
         "TLS1.3" : opt := [addrport, "ne", 5000, "minProto=TLS1.3"]
         "TLS1.2" : opt := [addrport, "ne", 5000, "minProto=TLS1.2", "maxProto=TLS1.2"]
         "TLS1.1" : opt := [addrport, "ne", 5000, "maxProto=TLS1.1"]
         default:  opt := [addrport, "n", 5000]
         }
end


procedure main(args)

   if not (&features == "secure sockets layer encryption") then
      stop("This program requires secure sockets layer encryption.")

   # test TCP first
   write("Running TCP socket test with no TLS ")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   writes("TCP Server:")
   thread Server(port, "na").run()
   delay(200)

   writes("TCP Client:")
   TCPClient(port, "n").run()

   # test secure sockets
   port := "localhost:" || (30000 + ?10000) # generate a random port

   write("\nRunning a server with a TLS socket")
   thread Server(port, "nae").run()

   delay(200)

   write("\nRunning test clients to the TLS server")

   every test := "No TLS" | "TLS" | "TLS1.3" | "TLS1.2" | "TLS1.1" | "Client Cert" do {
      delay(250)
      write("\nClient: ", test)
      TCPClient(port, test).run()
      }

   delay(200)
end
