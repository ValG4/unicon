procedure report_error(msg)
   static region
   initial region:=mutex()

   critical region: {
      writes(msg)
      writes(" Error ")
      if writes((&errornumber | (0 ~= &errno))) then
         writes(": ")

      # don't report connection errors from openssl since they
      # are platform dependent and can't be used with automated testing.
      if (&errornumber ~= 1) then
         writes(&errortext)
      writes( " - ", &errorvalue)
      }
      return
end

class Server(addrport, mode, opt, rounds)
   method run()
      local sock
      every !rounds do {
          sock := &null
          sock := tcp_socket(addrport) # block and wait to accept a new connection
          if \sock then 
             tcp_session(sock)
          delay(50)
         }
   end

   method tcp_socket()
      local s
      write("\nOpen a tcp server for test: ", mode)
      s := open ! opt |
         (report_error("\nserver open()") & fail)
      return s
   end

   method tcp_session(sock)
      repeat {
         if *select(sock) > 0 then {
            if (msg := ready(sock)) && msg ~=== "" then {
               writes(left("server:" || image(msg) || " => ", 20))
               writes(sock, msg)       # echo back to the client
               }
            else {  # We see activity on the socket but nothing to read, assume client has closed the socket
               close(sock)
               break # done, break out of the loop
            }
         }
      }
   end
   initially(p, m)
      addrport := p
      mode := m

      key := "key=./data/unicon-server.key"
      cert := "cert=./data/unicon-server.crt"
      ca := "caFile=./data/unicon-ca.crt"
      case mode of {
         "TLS": {
           rounds := 4
           opt := [addrport, "nae", key, cert, ca]
           }
        "TLS Versions": {
           rounds := 3;
           opt := [addrport, "nae", key, cert, ca, "minProto=TLS1.2"]
           }

        "Client Auth": {
           rounds := 2;
           opt := [addrport, "nae", key, cert, ca, "verifyPeer=yes"]
           }

         "AES256" : {
            rounds := 2
            opt := [addrport, "nae", 5000, key, cert, ca, "ciphers=AES256"]
            }

        "No TLS": {
           rounds := 1
           opt := [addrport, "na"]
           }

         default:  stop("server: what mode :", mode)
         }
end

class TCPClient(addrport, sock, mode, opt)
   method test(msg)
      local msg_reply
      writes(left("test> client:" || image(msg) || " => ", 28))

      writes(sock, msg) | (report_error("\n\nwrite(sock) Failed") & failed)
      if *select(sock) > 0 then
         if msg_reply := ready(sock) then {
            writes(" client: ")
            if msg == msg_reply then 
               write(left(image(msg_reply), 10), "OK")
            else
               write(left(image(msg_reply),10), "Failed")

            return
            }
         else  (report_error("\n\nclient ready(): ") & fail)
      return
   end

   method run()
      write("\nOpen a tcp client socket for test: ", mode)
      sock := (open ! opt) |
         (report_error("\nclient open()") & fail)

      test("Unicon") &
      test("Is") &
      test("Awesome")

      close(sock)
   end

   initially(p, m)
      addrport := p
      mode := m
      key := "key=./data/unicon-client.key"
      cert := "cert=./data/unicon-client.crt"
      ca := "caFile=./data/unicon-ca.crt"

      case mode of {

         "No TLS":  opt := [addrport, "n", 5000]

         "TLS No CA" : opt := [addrport, "ne", 5000]
         "TLS No Verify" : opt := [addrport, "ne", 5000, "verifyPeer=no"]
         "TLS" | "TLS No Cert" | "TLS With CA" : opt := [addrport, "ne", 5000, ca]

         "TLS1.1" : opt := [addrport, "ne", 5000, ca, "maxProto=TLS1.1"]
         "TLS1.2" : opt := [addrport, "ne", 5000, ca, "minProto=TLS1.2", "maxProto=TLS1.2"]
         "TLS1.3" : opt := [addrport, "ne", 5000, ca, "minProto=TLS1.3"]

         "Client Auth" : opt := [addrport, "ne", 5000, key, cert, ca ]

         "AES128" | "AES256" : opt := [addrport, "ne", 5000, ca, "ciphers="||mode]

         default:  stop("client: what mode :", mode)
         }
end


procedure main(args)

   if not (&features == "secure sockets layer encryption") then
      stop("This program requires secure sockets layer encryption.")

   #----------------------
   write("Basic socket Test")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   thread Server(port, "No TLS").run()
   delay(200)
   TCPClient(port, "No TLS").run()

   #----------------------
   write("\nEncrypted sockets test")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   thread Server(port, "TLS").run()
   delay(200)
   every test := "No TLS" | "TLS No CA" | "TLS No Verify" | "TLS With CA" do {
      delay(250)
      TCPClient(port, test).run()
      }
   delay(200)

   #----------------------
   write("\nTLS versions test")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   thread Server(port, "TLS Versions").run()
   delay(200)
   every test := "TLS1.1" | "TLS1.2" | "TLS1.3" do {
      delay(250)
      TCPClient(port, test).run()
      }
   delay(200)

   #----------------------
   write("\nClient authentication test")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   thread Server(port, "Client Auth").run()
   delay(200)
   every test := "TLS No Cert" | "Client Auth" do {
      delay(250)
      TCPClient(port, test).run()
      }


   #----------------------
   write("\nCiphers test")
   port := "localhost:" || (30000 + ?10000) # generate a random port

   thread Server(port, "AES256").run()
   delay(200)
   every test := "AES128" | "AES256" do {
      delay(250)
      TCPClient(port, test).run()
      }


   delay(200)
end
