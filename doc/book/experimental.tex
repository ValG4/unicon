\chapter{Experimental Features}

The designers of Unicon have taken a very conservative approach when adding to
the language and when changing existing features. With the small number of
exceptions that have been previously noted on page \pageref{Unicon-Icon}, an
Icon program that runs on the final version of Icon (version 9.5, first released
in 1996) will run on the current Unicon system {\em and give the same results\/}
a quarter of a century later. The conservative approach is continued when
dealing with additions to Unicon; breaking existing Unicon programs by making an
incompatible change to the language is, in most circumstances, considered to be
a very bad thing to do.

Most of the development of Unicon starting from its progenitor has already been
discussed but there are some more experimental features that are waiting in the
wings. Some of them may never see the light of day in their present form -- or,
perhaps, in any form -- so the most cautious approach is not to rely on any of
them until they make their way from this appendix into the definition of the
language in Appendix A.

The experimental features are not usually enabled by default in a
release build of Unicon -- they can only be accessed by making the appropriate
pre-processor definitions (or, in some cases, by specifying additional arguments
to \texttt{configure}) and rebuilding the system from the source code. Some
features that are now part of the language -- for example, the array extension
to lists that makes them faster in many cases -- are still guarded by
pre-processor definitions, showing their pedigree as experimental additions, but
are now enabled by default. The plugin mechanism and the installed plugins are
an exception to the general rule: they {\em are\/} enabled by default but should
still be considered experimental and subject to change.

A Unicon Technical Report (UTR) is the preferred vehicle for introducing a
change to Unicon.  The UTR, and associated code, may undergo several rounds of
revision before being considered ready for adoption. When it is (ready), the UTR
material will usually be incorporated somewhere into the book. UTRs may be found
at \url{http://unicon.org/reports.html}. Note that {\em all\/} of the reports
are there, including those that have served their purpose and are no longer
under active development.

%% Candidates for inclusion
%%
%% UTF-8

\section{User defined operators}
This feature extends the syntax of classes to allow the built-in operator
symbols to be redefined when their operands are objects. It may be enabled by
using the \texttt{-{}-enable-ovld} option to \texttt{configure} before
rebuilding the Unicon system.

\section{Extensions to \texttt{\&random}}
This feature allows the programmer to choose from a portfolio of different
random number generators (in addition to the one provided by Icon). It is also
possible to implement other generators and use them without rebuilding Unicon.
More than one generator may be in use at the same time.
It may be enabled by defining the C preprocessor symbol \texttt{RngLibrary}
before rebuilding the Unicon system.

\section{Plugins}
\index{Plugins}
A Unicon plugin is a dynamically loaded library of routines that are
encapsulated by a class, which provides access to the external routines (often
written in another language) plus a simple facility to enumerate the routines
that are available. The external routines may be part of the source code of the
plugin or in a separately compiled library that is acquired and installed from
elsewhere. At the minimum, a plugin provides a translation layer that converts
the arguments to the routines from their Unicon representation into something
compatible with the calling conventions of the external implementation language;
but usually the plugin also ``adds value'' by providing a more Unicon-like way
of accessing the underlying routines.

\subsection{Bitman}
\index{Bitman plugin}
The \texttt{Bitman} plugin provides low level bit manipulation routines that are
the equivalent of the built-in functions (\texttt{iand}, \texttt{ior},
\texttt{ishift} etc.). The salient differences -- and the reason for their
existence -- between the \texttt{Bitman} methods and the built-in functions is
that the \texttt{Bitman} methods never produce a large integer, are confined to
the natural word length of the machine (so the results are not portable between
32-bit and 64-bit implementations) and, except for bit shifting, do not make a
special case of the sign bit.  \texttt{Bitman} also provides some bit level
enquiry and extraction methods that use a similar addressing convention to
string indexing (indexing bits instead of characters).

The methods provided by the plugin are
\begin{center}
\begin{xtabular}{|m{0.5in}|m{2.5in}|m{0.5in}|}
    \hline
    \texttt{band}   & bitwise AND              & (\texttt{iand})\\
    \texttt{bcom}   & bitwise one's complement & (\texttt{icom})\\
    \texttt{bit}    & (single) bit extraction  &\\
    \texttt{bits}   & enquiry and multi-bit extraction &\\
    \texttt{bor}    & bitwise inclusive OR     & (\texttt{ior})\\
    \texttt{brot}   & bit rotation             &\\
    \texttt{bshift} & bitwise shift            & (\texttt{ishift})\\
    \texttt{bxor}   & bitwise exclusive OR     & (\texttt{ixor})\\
    \texttt{ushift} & unsigned bitwise shift   &\\
    \texttt{test}   & confidence testing       &\\
    \hline
\end{xtabular}
\end{center}
The actual bit manipulation code (written in C) is part of the source code for
the plugin: no external libraries are required. The \texttt{Bitman} class has no
attributes, so the constructor function has no parameters.
\bigskip\hrule\vspace{0.1cm}
\index{band}
\noindent
{\bf band(i, i) : integer } \hfill {\bf bitwise and}

\noindent
\index{bitwise and}\texttt{band(i1, i2)} produces the bitwise AND of
\texttt{i1} and \texttt{i2}.

\bigskip\hrule\vspace{0.1cm}
\index{bcom}
\noindent
{\bf bcom(i) : integer } \hfill {\bf bitwise complement}

\noindent
\texttt{bcom(i)} produces the bitwise complement (one's
complement) of \texttt{i}.

\bigskip\hrule\vspace{0.1cm}
\index{bit}\index{bit extraction}
\noindent
{\bf bit(i, i) : integer ? } \hfill {\bf single bit extraction}

\noindent
\texttt{bit(i,n)} returns the value of the \texttt{n}$^{th}$
bit of \texttt{i}. The indexing works the same way as strings:\\
\texttt{bit(i,1)} is the least significant bit of \texttt{i}.\\
\texttt{bit(i,0)} is the most significant bit of \texttt{i}.\\
\noindent If \texttt{n} is negative, indexing is from the most significant end,
otherwise it is from the least significant end.

\bigskip\hrule\vspace{0.1cm}
\index{bits}\index{multi-bit extraction}
\noindent
{\bf bits(i, i, i) : integer ? } \hfill {\bf multi-bit extraction}

\noindent
\texttt{bits(i,n,m)} returns the value of the \texttt{n}$^{th}$ to the
\texttt{m}$^{th}$ bit of \texttt{i}. The value is shifted down to the
least significant end of the machine word. The bits are {\em not\/} reversed if
\verb|m < n|.

\noindent \texttt{bits()} returns the number of bits in a word -- usually 32 or 64.

\bigskip\hrule\vspace{0.1cm}
\index{brot}
\noindent
{\bf brot(i, i) : integer } \hfill {\bf bitwise rotation}

\noindent
\index{bit rotation}\texttt{brot(i, j)} produces the value obtained by
rotating \texttt{i} by \texttt{j} bit positions.
If \texttt{j} is positive, the rotation is to the left;
if \texttt{j} is negative, the rotation is to the right.

\bigskip\hrule\vspace{0.1cm}
\index{bor}
\noindent
{\bf bor(i, i) : integer } \hfill {\bf bitwise or}

\noindent
\index{bitwise or}\texttt{bor(i1, i2)} produces the bitwise OR of
\texttt{i1} and \texttt{i2}.

\bigskip\hrule\vspace{0.1cm}
\index{bshift}
\noindent
{\bf bshift(i, i) : integer } \hfill {\bf signed bitwise shift}

\noindent
\index{signed shift}\texttt{bshift(i, j)} produces the value obtained by
shifting \texttt{i} by \texttt{j} bit positions.
If \texttt{j} is positive, the shift is to the left, and vacated bit
positions are filled with zeros.
If \texttt{j} is negative, the shift is to the right with sign extension.

\bigskip\hrule\vspace{0.1cm}
\index{ushift}
\noindent
{\bf ushift(i, i) : integer } \hfill {\bf unsigned bitwise shift}

\noindent
\index{unsigned shift}\texttt{ushift(i, j)} produces the value obtained by
shifting \texttt{i} by \texttt{j} bit positions.
The shift is to the left, if \texttt{j} is positive, or to the right if
\texttt{j} is negative.  Vacated bit positions are filled with zeros.

\subsection{SecureHash}
\index{SecureHash plugin}
The \texttt{SecureHash} plugin provides access to an implementation of the
RFC6324 secure hash routines. This is an extract from the description:
\begin{quote}
{\small
  This file implements the Secure Hash Algorithms
  as defined in the U.S. National Institute of Standards
  and Technology Federal Information Processing Standards
  Publication (FIPS PUB) 180-3 published in October 2008
  and formerly defined in its predecessors, FIPS PUB 180-1
  and FIP PUB 180-2.

  A combined document showing all algorithms is available at\\
  http://csrc.nist.gov/publications/fips/fips180-3/fips180-3\_final.pdf

  The five hashes are defined in these sizes:\\
  \begin{xtabular}{m{1.0in}m{3.0in}}
      \texttt{SHA-1}       &    20 byte / 160 bit\\
     \texttt{SHA-224}     &    28 byte / 224 bit\\
     \texttt{SHA-256}     &    32 byte / 256 bit\\
     \texttt{SHA-384}     &    48 byte / 384 bit\\
     \texttt{SHA-512}     &    64 byte / 512 bit\\
   \end{xtabular}
}
\end{quote}

\noindent Modified versions of the RFC6324 routines -- to make them thread-safe
-- are included in the source code of the plugin: no external libraries are
required.

Access to the hashing routines is provided at two levels
\begin{itemize}
  \item The higher (and most convenient) level is provided by the
    \texttt{SecureHash} class using the \texttt{Sha} method.
  \item At the lower level, the individual RFC6324 routines may be accessed
    directly, without using the \texttt{SecureHash} class, via the interface
    procedures provided by the plugin.
\end{itemize}

\noindent
Parameters to \texttt{Sha} may be strings, csets, open files, numbers, records or lists.\\
   String parameters are ``fed to the underlying hash routines'' ({\em fttuhr});\\
   if the parameter is a cset, each character in the set is {\em fttuhr\/};\\
   if the parameter is an open file, each line of the file is read and {\em fttuhr\/};\\
   if the parameter is a number, it is converted to a string and {\em fttuhr\/}.\\
\noindent
\texttt{Sha} applies itself recursively to list or record parameters (depth
first traversal). So records and lists may contain strings, csets, open files,
numbers, records or lists. \texttt{Sha} is tolerant of null parameters and empty
strings, csets, files or lists; they have no effect on the final hash value.

Sets and Tables are not allowed as parameters to \texttt{Sha} because their order of
enumeration is not defined. Any other type (thread, co-expression, window ...)
is also disallowed by fiat, with one exception: A procedure value%
\footnote{
A procedure value is a convenient way to steer the operation of the
\texttt{Sha} routine because it cannot be confused with any data to be added to
the hash value.}%
, using special ``command procedures'', may be used to signal that \texttt{Sha}
should take some special action as follows:
\begin{itemize}
  \item
    The procedure \texttt{More} is allowed as the final parameter. Normally the
    \texttt{Sha} method returns the secure hash of all its parameters, but if
    the final parameter is the procedure \texttt{More}, subsequent calls to
    \texttt{Sha} will continue the hashing operation.
    Note the style is
\iconcode{ Sha( ... , More ) }
\noindent rather than
\iconcode{
  Sha( ... , More() )
}
\noindent although the latter has been made to work as a ``concession to ease of use''.

\item
  The procedures \texttt{Final1} ... \texttt{Final7} may be used to signal that
  the final parameter to \texttt{Sha} is not a whole octet, only the specified
  number of bits are to be included in the hash. These procedures are only
  allowed just before the final parameter.  Where the final number of bits is
  calculated, the \texttt{Final(expr)} procedure may be
  used. \verb|0 <= expr <= 8|. (There is a \texttt{Final0} procedure, but using
  it explicitly would be slightly odd, since it will cause the final parameter
  to be ignored. There is also a \texttt{Final8} procedure which causes all of
  the final parameter to be included. These procedures are intended for use by
  the \texttt{Final} procedure).

\item
  The \texttt{Raw} procedure switches the default output from a string of
  hexadecimal characters to a string of half the length containing the actual
  bits returned by the RFC6234 result procedure. It may be placed anywhere in
  the list of parameters.
\end{itemize}

Note that \texttt{Sha(number)} will return a secure hash of the string
representation of the number, not a hash of the underlying bits. If a hash of
the bits is required, the only way to do it is to convert the number to a string
of the correct length (and endianness) without altering the value of the bits
-- Unicon strings may contain characters with all values from 0 to 255 -- this
also applies to the lower level \texttt{sha\_Input} procedure

Once \texttt{Sha} has produced a hash value (or failed) it will automatically
reset the underlying hash routines the next time it is called.

The \texttt{SecureHash} class is not thread-safe. \WarningNotThreadSafe
Using a shared \texttt{SecureHash} object in different threads without mutual
exclusion is unlikely to produce predictable results. Using a
\texttt{SecureHash} object that is private to each thread {\em is\/} safe
because the underlying hash routines are thread-safe.

The class is initialized with an optional string parameter that determines the
hash algorithm. Valid strings are \texttt{"SHA1"}, \texttt{"SHA224"},
\texttt{"SHA256"}, \texttt{"SHA384"} or \texttt{"SHA512"}.  The default is
\texttt{"SHA512"}.


The methods of the \texttt{SecureHash} class are:

\bigskip\hrule\vspace{0.1cm}
\index{Reset}
\noindent
{\bf Reset(s : "SHA512") : ? } \hfill {\bf Reset Secure Hash}

\noindent
\index{Reset()}\texttt{Reset(s)} re-initializes the secure hash instance.  The
optional parameter specifies the algorithm to use and must be one of \texttt{"SHA1"},
\texttt{"SHA224"}, \texttt{"SHA256"}, \texttt{"SHA384"} or \texttt{"SHA512"}.

\bigskip\hrule\vspace{0.1cm}
\index{Sha}
\noindent
{\bf Sha(any?, ...) : string ? } \hfill {\bf Secure Hash}

\noindent
\index{Sha()}\texttt{Sha(...)} returns the secure hash value of its
arguments, which are of the types discussed above.

\bigskip
The interface procedures of the \texttt{SecureHash} plugin are:

\bigskip\hrule\vspace{0.1cm}
\index{shaFunction}
\noindent
{\bf shaFunction(s?) : string ? } \hfill {\bf Set/Get default Hash function}

\noindent
\index{shaFunction()}
\texttt{shaFunction(h)} sets the default hash algorithm.  Valid strings are
\texttt{"SHA1"}, \texttt{"SHA224"}, \texttt{"SHA256"}, \texttt{"SHA384"} or
\texttt{"SHA512"}.  \texttt{shaFunction()} returns the name of the current
default algorithm.  The procedure is not thread-safe. \WarningNotThreadSafe

\bigskip\hrule\vspace{0.1cm}
\index{sha_Reset}
\noindent
{\bf sha\_Reset(s) : ctx ? } \hfill {\bf Initialize Secure Hash}

\noindent
\index{sha_Reset()}
\texttt{sha\_Reset(h)} initializes and returns an opaque context value that
should be fed into the other interface procedures. \texttt{h} determines the
hash algorithm. Valid strings are \texttt{"SHA1"}, \texttt{"SHA224"},
\texttt{"SHA256"}, \texttt{"SHA384"} or \texttt{"SHA512"}.

\bigskip\hrule\vspace{0.1cm}
\index{sha_Input}
\noindent
{\bf sha\_Input(ctx, s) : ? } \hfill {\bf Hash String}

\noindent
\index{sha_Input()}
\texttt{sha\_Input(x, s)} Adds the secure hash of \texttt{s} to the hash value
stored in \texttt{x}.

\bigskip\hrule\vspace{0.1cm}
\index{sha_FinalBits}
\noindent
{\bf sha\_FinalBits(ctx, c, i) : ? } \hfill {\bf Hash the final partial octet}

\noindent
\index{sha_FinalBits()}
\texttt{sha\_FinalBits(x, c, n)} Adds the secure hash of the most significant
\texttt{n} bits of \texttt{c} to the hash value stored in \texttt{x}.
\verb|1 <= n <= 7|

\bigskip\hrule\vspace{0.1cm}
\index{sha_RawResult}
\noindent
{\bf sha\_RawResult(ctx) : string ? } \hfill {\bf Return the raw hash value}

\noindent
\index{sha_RawResult()}
\texttt{sha\_RawResult(x)} returns the final hash value in the exact form
returned by the RFC6324 hash routines. The returned string will be a binary
string and may contain any character value from \texttt{char(0)} to
\texttt{char(255)}.

\bigskip\hrule\vspace{0.1cm}
\index{sha_Result}
\noindent
{\bf sha\_Result(ctx) : string ? } \hfill {\bf Return the hash value}

\noindent
\index{sha_Result()}
\texttt{sha\_Result(x)} returns the final hash value converted to a string of
hexadecimal characters.

%-------------------- To Do --------------------
%\subsection{SQLite}
%\label{SQLite Plugin}
%\label{SQLiteClass}
